---
title : '异步编程-所有权'
---

假设这样一种场景，我们定义了一个结构体 `Request` 用于请求远程数据，结构体内含有一个异步方法 `do_req` 用于执行请求，并且假设每个请求等待一秒钟后简单返回发送数字的两倍：

```rust
use std::time::Duration;
use tokio::time::sleep;

pub struct Request {}

impl Request {
    pub async fn do_req(&self , num : i32) -> i32 {
        sleep(Duration::from_secs(1)).await;
        num * 2
    }
}
```

接下来我们定义两个结构体，并分别执行两个结构体的请求方法，收集请求获取到的数据，具体执行顺序为：
1. 在变量 `v` 中定义两个请求结构体
2. 迭代 `v` 生成两个实现了 `Future trait` 的异步任务
3. 调用 `join_all` 执行两个异步任务
4. 打印结果

```rust
use futures::future::join_all;

#[tokio::test]
async fn test() {
    let r1 = Request{};
    let r2 = Request{};
    let v = vec![r1 , r2];

    let futs : Vec<_> = v.into_iter().map(|req|{
        req.do_req(1)
    }).collect();

    let res = join_all(futs).await;

    println!("{:?}", res);
}
```

但在第二步生成异步任务时，却会得到编译器抛出的错误:

*cannot return value referencing function parameter `req`
returns a value referencing data owned by the current function*

让我们看看发生了什么：
1. `v.into_iter` 将 `v` 的所有权转移到迭代器的闭包函数中，即转移到 `req` 变量中
2. `req.do_req(1)` 生成了一个 `Future` 对象，当我们对其调用 `Future.await` 时，该对象会**根据指针**寻找原结构体，并执行其 `req.do_req(1)` 方法
3. 闭包函数的变量 `req` 随着闭包的结束而销毁，因为 `v` 将所有权交给了 `req` ，因此原结构体也被销毁，而根据指针查找原结构体的 `Future` 对象也法执行 `req.do_req(1)` 的操作。

**解决办法：**

用 `v.iter()` 代替 `v.into_iter()` ，前者在闭包内获取原数组对象的引用而不获取其所有权，当 `req` 销毁时，引用被还给了 `v` ，因此 `Future` 指针可以正确找到 `v` 中的 `Request` 结构体并执行 `Request.do_req(1)` 方法。




