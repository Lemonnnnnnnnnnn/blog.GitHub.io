---
title : '枚举enum、空值None与match'
---

## 枚举

**枚举 = struct + interface.**

你可以单纯将枚举当作某一类型的常量来使用，这使它起到了**接口 interface **的作用：

```rust
fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind, // 将枚举当作接口类型来使用
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4, // 分配枚举常量
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
}
```

我们也可以给枚举值分配一个变量，**这使枚举的用法更像结构体 struct**，比如：

```rust
fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
}
```

枚举值也可以接受结构体：

```Rust
fn main() {
  struct Ipv4Addr {
      // --snip--
  }

  struct Ipv6Addr {
      // --snip--
  }

  enum IpAddr {
      V4(Ipv4Addr),
      V6(Ipv6Addr),
  }
}
```

我们经常会在 [match](#match) 中使用枚举绑定的值。

## 空值与 Option

rust 中对空值** null **的定义非常的严格，因为空值是引起运行错误的一个重要来源。因此其作出规定，只有一种变量可能为空，那就是 `Option` 型变量。

```rust
#![allow(unused)]
fn main() {
  enum Option<T> {
      None,
      Some(T),
  }
}

fn main() {
    let some_number = Some(5); // 推断类型为 Option<number>
    let some_char = Some('e'); // 推断类型为 Option<char>

    let absent_number: Option<i32> = None; // 必须提前定义空值的类型
}
```

要使用 `Option<T>` 枚举对象，必须提前将其转换为 `T` ，即**非空值**来运行。

总结：所有的 `null` 都保存在 `Option` 枚举对象中，这给程序的运行带来了安全。

## match

`match` 基本使用方法：`=>` 指向返回结果 

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

fn main() {}

```

在 `match` 中使用枚举变量绑定的值：

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}

fn main() {
    value_in_cents(Coin::Quarter(UsState::Alaska));
}

```

`match` 与 `Option` 配合使用：

```rust
fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5); // 因为非常常用，所以 Option 的 Some 和 None 可以直接使用，相当于预置了 use Option;
    let six = plus_one(five);
    let none = plus_one(None);
}

```

rust 中的 `match` 是**穷尽的**，**你必须在 match 中对所有的枚举值进行处理：**

```rust
// 没有处理 Option 的 none 枚举值，因此无法通过编译

fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}

```

数字也是一种枚举值，你可以使用 match 来匹配数字，但我们无法穷举数字，因此我们可以使用一种 **通配模式**：

```rust
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        others => move_player(others), // 最后一个分支匹配其他数字
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
}

```

通配模式的变量可以任意选择，但其中有一个关键字比较特殊： `_` ，它表示**不使用匹配到的值**。

```rust
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => move_player(_), // 报错
        // in expressions, `_` can only be used on the left-hand side of an assignment
        // `_` not allowed here
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
}

```

**关于 match 的返回值：**

> Rust 要求 match 的**每个分支返回值类型必须相同，且如果是一个单独的 match 表达式而不是赋值给变量时，每个分支必须返回 () 类型**。 

## if let

因为 rust 中没有 null，所以判断是否为空不能使用 `if,else` 语句来处理，我们只能用 `match` :

```rust
fn main() {
    let config_max = Some(3u8);
    match config_max {
        Some(max) => println!("The maximum is configured to be {}", max),
        _ => (), // 处理 none
    }
}
```

为了处理这种常用场景，rust 提供了一种语法糖 ： `if let` :

```rust
fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
}
```
**解析：**

```rust
let config_max = Some(3u8);
// 根据自动推断等于
let config_max : Option<u8> = Some(3u8);
```

而 `config_max : Option<u8>` 可以等于 `Some<u8>` 或 `None` 。于是我们可以把上面的代码写的完整一些：

```rust
fn main() {
    let config_max : Option<u8> = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }else if let None = config_max {

    }
}
```

- 如果 `if let Some(max) = config_max` 赋值成功，则说明 `config_max` 的枚举类型是 `Some` 。
- 如果 `if let None = config_max` 赋值成功，则说明 `config_max` 的枚举类型是 `None` 。
从而执行相应的条件语句分支代码。
