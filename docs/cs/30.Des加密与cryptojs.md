---
title: 'Des加密与cryptojs'
---

由于现今的web开发环境以前后端分离居多，那么一定会有敏感数据从前端传输到后端的情景，比如用户密码。如果传输明文密码，很容易被抓包软件捕获并泄露用户信息。

因此我们可以将数据进行一层加密再传输，加密方式由许多种，*Des , 3Des , Aes ...* ，我们这里用 `Des` 简单举例，如果你感兴趣算法的底层实现，可以参考 [神秘的 DES 加密算法](https://cloud.tencent.com/developer/article/1497864) 这篇文章，我们只在此介绍用法，并且记录一下 js 加密库 `cryptojs` 的使用方法：

用 `cryptojs` 来实现一个 des 加密十分简单，只需要十一行代码：

```js
  encryptByDES(message) {
    const keyHex = CryptoJS.enc.Utf8.parse(desKey); 
    const messageHex = CryptoJS.enc.Utf8.parse(message);
    const encrypted = CryptoJS.DES.encrypt(messageHex, keyHex, {
      mode: CryptoJS.mode.ECB,  // 加密方式ECB模式
      padding: CryptoJS.pad.Pkcs7 // 以Pkcs7的方式填充
    });
    
    // 将结果转换为16进制字符串
    const res = encrypted.ciphertext.toString().toUpperCase()
  
    return res;

  }
```

**解析：**
- `CryptoJS.enc.Utf8.parse(string)` 帮我们将传入的字符串转换为一个 cryptojs 对象，其中保存着加密密文 `ciphertext` 等数据和方法。
- `CryptoJS.DES.encrypt(value , key , options)` : 允许我们传入值和密钥，以及方法参数。
- **ECB模式**：电子密本方式，就是将数据按照**8个字节**一段进行DES加密或解密得到一段8个字节的密文或者明文，最后一段不足8个字节，则补足8个字节（注意：这里就涉及到数据补位了）进行计算。
- **Pkcs7填充模式**：对加密数据字节长度对8取余为r，如r大于0，则补8-r个字节，字节为8-r的值；如果r等于0，则补8个字节。

加密的结果 `encrypted` 是一个 cryptojs 对象. 它内置的 `encrypted.toString()` 方法会帮我们将密文转换为一个 `base64` 对象 :

```js
encrypted.toString(); // 密文的base64结果
```

但这里有个坑，如果直接对密文对象 `encrypted.ciphertext` 调用 `.toString()` 方法，则会得到另一个结果：

```js
encrypted.ciphertext.toString(); // hex格式密文，即密文的16进制形式
```

`cryptojs` 还为我们提供了一系列编码解码器，比如我们可以使用 `CryptoJS.enc.Hex.stringify()` 将一个密文对象转换为密文的16进制形式. 这和上面直接调用 `toString()` 方法得到的结果相同：

```js 
CryptoJS.enc.Hex.stringify(encrypted.ciphertext);
```

至于要用 `base64` 格式还是 `hex` 格式进行数据传输，则要和后端约定好他们希望以哪种方式进行解码来选用即可。

其他用法可以参考 `cryptoJs` 的官方文档：`https://cryptojs.gitbook.io/docs/`。
