import{_ as o,M as c,p as r,q as i,R as a,t as e,N as s,a1 as d}from"./framework-c8e009f3.js";const l={},t=a("h2",{id:"什么是ocrmypdf",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#什么是ocrmypdf","aria-hidden":"true"},"#"),e(" 什么是ocrmypdf")],-1),p={href:"https://ocrmypdf.readthedocs.io/en/latest/introduction.html",target:"_blank",rel:"noopener noreferrer"},u=d(`<h2 id="快速使用" tabindex="-1"><a class="header-anchor" href="#快速使用" aria-hidden="true">#</a> 快速使用</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-i</span> <span class="token parameter variable">--rm</span> jbarlow83/ocrmypdf - - <span class="token operator">&lt;</span>当前文件夹下需要转换的pdf文件名 <span class="token operator">&gt;</span>output.pdf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="使用dockerfile打包-识别中文" tabindex="-1"><a class="header-anchor" href="#使用dockerfile打包-识别中文" aria-hidden="true">#</a> 使用Dockerfile打包，识别中文</h2><p>到需要处理的PDF所在文件夹中，新建 <em>Dockerfile</em> 文件，并键入：</p><div class="language-Dockerfile line-numbers-mode" data-ext="Dockerfile"><pre class="language-Dockerfile"><code># 拉取镜像
FROM jbarlow83/ocrmypdf
# 工作地址，用于在运行时建立同步卷
WORKDIR /app
# 安装汉字数据集，用于OCR识别汉字
RUN apt install tesseract-ocr-chi-sim
# 将当前文件夹下的PDF文件拷贝到容器内
COPY . .
# 在调用docker run 时执行以下命令
ENTRYPOINT [&quot;ocrmypdf&quot;, &quot;-l&quot; , &quot;chi_sim&quot;  ,&quot;input_pdf 名字自行调整&quot;, &quot;out_pdf 名字自行调整&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打包docker镜像：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> build <span class="token parameter variable">-t</span> ocrmypdf <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用docker镜像建立容器并运行ocrmypdf：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-v</span> .:/app ocrmypdf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>windows下的文件夹路径格式为：<code>C:/foo/bar</code></p><p>linux下的文件夹路径格式为：<code>/C/foo/bar</code></p><p>如果在windows下建立同步卷使用了linux文件夹路径格式，则无法建立同步卷。</p></div><h2 id="问题记录" tabindex="-1"><a class="header-anchor" href="#问题记录" aria-hidden="true">#</a> 问题记录</h2><h3 id="能否在dockerfile中配置volume" tabindex="-1"><a class="header-anchor" href="#能否在dockerfile中配置volume" aria-hidden="true">#</a> 能否在Dockerfile中配置volume？</h3><p>不可以，Dockerfile文件是打包(docker build)配置文件，而volume是在运行(docker run)命令中指定的。</p>`,13),m={href:"https://docs.docker.com/compose/",target:"_blank",rel:"noopener noreferrer"},v=d(`<p>编写 <code>docker-compose.yml</code> :</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">services</span><span class="token punctuation">:</span>
<span class="token comment">#  默认会使用【当前文件夹名-ocrmypdf】作为image名字</span>
    <span class="token key atrule">ocrmypdf</span><span class="token punctuation">:</span>
      <span class="token comment"># 用当前文件夹下的Dockerfile文件进行打包</span>
      <span class="token key atrule">build</span><span class="token punctuation">:</span> .
      <span class="token comment"># 将当前文件夹作为docker内工作目录的映射卷</span>
      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> .<span class="token punctuation">:</span>/app
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker-compose</span> up
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>关闭并删除容器：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker-compose</span> down
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="我们为什么可以执行-run-apt-install-tesseract-ocr-chi-sim-apt-包管理工具哪来的" tabindex="-1"><a class="header-anchor" href="#我们为什么可以执行-run-apt-install-tesseract-ocr-chi-sim-apt-包管理工具哪来的" aria-hidden="true">#</a> 我们为什么可以执行 <code>RUN apt install tesseract-ocr-chi-sim</code> ， apt 包管理工具哪来的 ?</h3><p>我们是在拉取的镜像 <em>jbarlow83/ocrmypdf</em> 中运行这个命令，其内部对<code>apt install</code> 做了处理。</p><h3 id="dockerfile文件中的run、entrypoint、cmd命令的区别" tabindex="-1"><a class="header-anchor" href="#dockerfile文件中的run、entrypoint、cmd命令的区别" aria-hidden="true">#</a> Dockerfile文件中的<code>RUN、ENTRYPOINT、CMD</code>命令的区别？</h3><p><code>RUN</code> 和其他两个命令不同，它在打包时执行，另外两个命令在运行时执行。</p><p><code>CMD</code> 命令的格式为 <code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> ，如果用户在调用<code>docker run param3 param4</code>时提供了参数，则CMD的参数会被覆盖。</p><p><code>ENTRYPOINT</code> 命令和 <code>CMD</code> 的区别在于其参数<strong>不会</strong>被覆盖。</p>`,12);function h(b,k){const n=c("ExternalLinkIcon");return r(),i("div",null,[t,a("p",null,[a("a",p,[e("ocrmypdf"),s(n)]),e(" 可以用于处理扫描出的PDF文件，利用OCR识别其中的文字，以使用搜索文档的功能。")]),u,a("p",null,[e("如果想要在文件中配置运行时命令，请使用"),a("a",m,[e("Docker Compose"),s(n)]),e(".")]),v])}const g=o(l,[["render",h],["__file","100.ocrmypdf.html.vue"]]);export{g as default};
