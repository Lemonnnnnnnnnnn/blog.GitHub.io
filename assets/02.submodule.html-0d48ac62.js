import{_ as o,M as s,p as c,q as l,R as e,t,N as d,a1 as a}from"./framework-c8e009f3.js";const n={},r=a(`<h2 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h2><ol><li>添加一个子模块</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// git submodule add [git地址] [目录位置]
$ git submodule add https://xxx/gittest.git src/gittest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>克隆一个仓库后，子模块的文件夹默认为空，需要通过下列命令下载所有子模块</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git submodule update --init --recursive
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p><code>init</code> : 初始化本地配置文件，即更新<code>.git/config</code><code>update</code> : 下载子模块文件 <code>recursive</code> : 递归查找所有子模块</p></div><ol start="3"><li><p>子仓库更新后，更新子模块内容</p><ol><li>单独进入子模块pull</li><li><code>git submodule foreach git pull</code></li></ol></li><li><p>删除子模块</p></li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git submodule deinit [子项目名] // 在 .git/config 中删除子项目依赖
git rm [子项目名]   // 移除子项目文件夹，并在.gitmodules中删除子项目依赖
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>需要手动删除<code>.git/modules</code> 目录下的子模块，否则拉取远程子模块代码会先读这里的本地缓存</p></div><h2 id="使用例子" tabindex="-1"><a class="header-anchor" href="#使用例子" aria-hidden="true">#</a> 使用例子</h2><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h3><p>新建两个仓库<code>inner-repo 和 nested-repo</code><img src="https://s2.loli.net/2022/04/19/fwtou8gBkGr7sLZ.png" alt=""></p><p>给主仓库<code>nested-repo</code>添加<code>submodule</code>并推送 <img src="https://s2.loli.net/2022/04/19/1W6Bjvos8UHJqtr.png" alt=""><img src="https://s2.loli.net/2022/04/19/cQ7l5DUnmGzeMgd.png" alt=""></p><h3 id="_1-修改子仓库-并在主项目更新子模块" tabindex="-1"><a class="header-anchor" href="#_1-修改子仓库-并在主项目更新子模块" aria-hidden="true">#</a> 1. 修改子仓库，并在主项目更新子模块</h3><p>到子仓库<code>inner-repo</code>修改<code>README</code>文件，并推送 <img src="https://s2.loli.net/2022/04/19/4xaR6LscWUmGfCb.png" alt=""><img src="https://s2.loli.net/2022/04/19/jsAxdeuwRF1nXCc.png" alt=""></p><p>可以看到主仓库中的子模块记录了一个版本号，点击跳转来到子仓库后可以看到出现了一个<code>游离分支</code>,其中的README文件为旧文件 <img src="https://s2.loli.net/2022/04/19/4D5agbMFXC1GHvE.png" alt=""><img src="https://s2.loli.net/2022/04/19/eWCTvNy1MiZFKUh.png" alt=""> 分支值实际上是<code>最后一次commit的 hash值</code></p><blockquote><p>游离分支：不存在于源仓库中的临时分支。</p></blockquote><p>我们通过<code>git submodule foreach git pull</code>命令更新主仓库的子模块内容 <img src="https://s2.loli.net/2022/04/19/wjcVmynTGlKozWL.png" alt=""></p><h3 id="_2-clone带子模块的仓库-并进行修改提交" tabindex="-1"><a class="header-anchor" href="#_2-clone带子模块的仓库-并进行修改提交" aria-hidden="true">#</a> 2. clone带子模块的仓库，并进行修改提交</h3><p><img src="https://s2.loli.net/2022/04/19/Zt5w2cVFUY8bHjO.png" alt=""> clone下来后发现子模块的文件夹为空，通过<code>git submodule update --init --recursive</code>命令拉取子模块代码 <img src="https://s2.loli.net/2022/04/19/6mWhMouvqdBJkcn.png" alt=""><img src="https://s2.loli.net/2022/04/19/W8Oc7KvLHrCyXMI.png" alt=""></p><p>修改子模块文件并推送，发现推送失败 <img src="https://s2.loli.net/2022/04/19/cwXVd9AxE57l1rW.png" alt=""><img src="https://s2.loli.net/2022/04/19/p8iAOZ73KzJdw9k.png" alt=""> 这是因为我们clone下来的项目子模块处于<code>游离分支</code>上，源仓库是没有这个分支的，我们需要指定推送分支： <img src="https://s2.loli.net/2022/04/19/p73dZzNWUKV4mHq.png" alt=""></p><p>当然，更好的办法是在<strong>clone下仓库后，将子模块的分支从游离分支切换到工作分支上</strong>。这样我们就可以直接在该分支上进行正常开发推送了。</p><h2 id="submodule原理" tabindex="-1"><a class="header-anchor" href="#submodule原理" aria-hidden="true">#</a> submodule原理</h2><ol><li>给主仓库添加子模块实际上是添加了一个子模块的<strong>指针</strong>，即子模块<code>最后一次commit的的hash值</code>。</li></ol><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>事实上，<code>commit的hash值</code>在并不是在执行<code>git commit</code>命令时生成的，而是第一次修改文件时生成的。</p><p>因此在可视化工具中可以看到，只要一修改子模块，主仓库的子模块指针立刻就改变了。</p></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>子模块修改一定有两次commit</p><p>子模块正常commit</p><p>主仓库指针commit</p></div>`,26),p={href:"https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97",target:"_blank",rel:"noopener noreferrer"};function u(m,h){const i=s("ExternalLinkIcon");return c(),l("div",null,[r,e("p",null,[t("更详细的子模块解释，请参考"),e("a",p,[t("文档"),d(i)])])])}const v=o(n,[["render",u],["__file","02.submodule.html.vue"]]);export{v as default};
