import{_ as n,M as i,p as c,q as t,R as e,t as d,N as o,a1 as s}from"./framework-c8e009f3.js";const l={},r=s(`<h2 id="inputrc" tabindex="-1"><a class="header-anchor" href="#inputrc" aria-hidden="true">#</a> inputrc</h2><p><code>inputrc</code> 文件为特定的情况处理键盘映射，在 <code>ubuntu</code> 系统中，默认路径为<code>/etc/inputrc</code></p><p>用户文件可以覆盖系统文件执行<code>~/.inputrc</code></p><p>常用的配置如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 按一次Tab就显示出所有的模糊匹配路径名</span>
<span class="token builtin class-name">set</span> show-all-if-ambiguous on
<span class="token comment"># 通过在列表项目尾部添加指示符号来说明类型，例如：@代表符号链接、/代表目录等</span>
<span class="token builtin class-name">set</span> visible-stats on
<span class="token comment"># 匹配字符显示强调色</span>
<span class="token builtin class-name">set</span> colored-completion-prefix on
<span class="token comment"># 匹配时忽略大小写</span>
<span class="token builtin class-name">set</span> completion-ignore-case on
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意，在修改完<code>~/.inputrc</code>文件，要显式执行<code>bind -f ~/.inputrc</code>才会生效。</p></blockquote><h2 id="环境变量" tabindex="-1"><a class="header-anchor" href="#环境变量" aria-hidden="true">#</a> 环境变量</h2><p>修改<strong>当前用户</strong>的环境变量： <code>sudo vim ~/.bashrc</code> 修改<strong>所有用户</strong>的环境变量： <code>sudo vim /etc/profile</code></p><p>声明一个环境变量：将 <code>export VAR_NAME=value</code> 按需求<strong>追加</strong>入上面两个文件中。其中 <code>VAR_NAME</code> 为环境变量名，<code>value</code> 为环境变量值。</p><p>通过 <code>source ~/.bashrc</code> 或 <code>source /etc/profile</code> 让环境变量生效。</p><p><strong>解析：</strong></p><ul><li><code>source [文件]</code> 表示<strong>逐条</strong>执行文件中的语句</li><li>在主机启动的过程中会先执行<code>/etc/profile</code>，再执行<code>~/.bashrc</code>，因此用户配置的环境变量优先级更高。</li><li>因为 <code>source</code> 本质上就是执行<em>bash</em>语句，所以我们直接在终端执行 <code>export VAR_NAME=value</code> 可以达到临时配置环境变量的效果，但会在关闭终端后失效。</li></ul><h3 id="代理配置" tabindex="-1"><a class="header-anchor" href="#代理配置" aria-hidden="true">#</a> 代理配置</h3><p>临时代理配置：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token assign-left variable">http_proxy</span><span class="token operator">=</span><span class="token string">&quot;http://127.0.0.1:8889&quot;</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">https_proxy</span><span class="token operator">=</span><span class="token string">&quot;https://127.0.0.1:8889&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>取消代理：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">unset</span> http_proxy
<span class="token builtin class-name">unset</span> https_proxy
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>永久代理配置：</p><ol><li>将上面的 <code>export</code> 语句加入 <code>/etc/profile</code> 文件或是 <code>~/.bashrc</code> .</li><li><code>source [文件名]</code></li></ol><h3 id="wget代理配置" tabindex="-1"><a class="header-anchor" href="#wget代理配置" aria-hidden="true">#</a> wget代理配置</h3><p>新建<code>~/.wgetrc</code>.</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#You can set the default proxies for Wget to use for http, https, and ftp.</span>
<span class="token comment"># They will override the value in the environment.</span>
https_proxy <span class="token operator">=</span> http://127.0.0.1:7890/
http_proxy <span class="token operator">=</span> http://127.0.0.1:7890/
ftp_proxy <span class="token operator">=</span> http://127.0.0.1:7890/

<span class="token comment"># If you do not want to use proxy at all, set this to off.</span>
use_proxy <span class="token operator">=</span> on
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="全局命令" tabindex="-1"><a class="header-anchor" href="#全局命令" aria-hidden="true">#</a> 全局命令</h2><h4 id="单个脚本" tabindex="-1"><a class="header-anchor" href="#单个脚本" aria-hidden="true">#</a> 单个脚本</h4><p>要执行全局命令，我们需要将命令加入 <code>PATH</code> 中。我们可以通过 <code>echo $PATH</code> 查看哪些文件夹下的命令已经在 <code>PATH</code> 中：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ubuntu@VM-12-7-ubuntu:~$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>各个文件夹用 <code>:</code> 分割开，这些文件夹下的可执行文件均可以用全局命令直接调用。例如我有一个文件 <code>/usr/local/sbin/clash</code>，那么我可以直接执行：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>clash <span class="token parameter variable">-v</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="项目入口文件" tabindex="-1"><a class="header-anchor" href="#项目入口文件" aria-hidden="true">#</a> 项目入口文件</h4><p>但有时候执行文件并不是单个脚本，这时候我们就要建立一个软链接（符号链接）到PATH路径下。格式为：<code>ln -s [源文件] [目标文件]</code>。</p><p>比如将目录/usr/mengqc/mub1 下的文件 m2.c 链接到目录 /usr/liu 下的文件 a2.c：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /usr/mengqc
<span class="token function">ln</span> mub1/m2.c /usr/liu/a2.c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="脚本文件夹" tabindex="-1"><a class="header-anchor" href="#脚本文件夹" aria-hidden="true">#</a> 脚本文件夹</h4><p>比如我们想要将jdk/bin下的所有命令作为全局命令，可以直接将文件夹添加到环境变量$PATH下。和<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">设置环境变量</a>一样，可以在 <code>~/.bashrc</code> 或 <code>/etc/profile</code> 文件中添加：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 加到PATH末尾</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:<span class="token punctuation">[</span>脚本文件夹路径<span class="token punctuation">]</span>

<span class="token comment"># 加到PATH开头</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token punctuation">[</span>脚本文件夹路径<span class="token punctuation">]</span>:<span class="token environment constant">$PATH</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="开机自动运行" tabindex="-1"><a class="header-anchor" href="#开机自动运行" aria-hidden="true">#</a> 开机自动运行</h2><h3 id="方法一" tabindex="-1"><a class="header-anchor" href="#方法一" aria-hidden="true">#</a> 方法一：</h3><p>在<code>/etc/rc.local</code> 中增加执行语句，例如：</p><p><img src="https://img.php.cn/upload/article/000/000/024/49eec79248d39d2b68971eca69faa9bd-0.png" alt=""></p><h3 id="方法二" tabindex="-1"><a class="header-anchor" href="#方法二" aria-hidden="true">#</a> 方法二：</h3><h4 id="在系统配置目录下编写服务文件" tabindex="-1"><a class="header-anchor" href="#在系统配置目录下编写服务文件" aria-hidden="true">#</a> 在系统配置目录下编写服务文件：</h4><p>在 <code>sudo vim /etc/systemd/system/</code> 目录下新建一个文件 <code>[name].service</code>.</p><div class="language-service line-numbers-mode" data-ext="service"><pre class="language-service"><code>[Unit] 
Description=clash daemon  
[Service] 
Type=simple 
User=&quot;your username&quot;  
ExecStart=&quot;runable file path&quot; # 你想要自启动的文件地址
Restart=on-failure  
[Install] 
WantedBy=multi-user.target
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,43),p={href:"https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html",target:"_blank",rel:"noopener noreferrer"},u=s(`<p><code>Install</code> 区块，定义如何安装这个配置文件，即怎样做到开机启动。</p><p><code>WantedBy</code> 字段：表示该服务所在的 <strong>Target</strong> 。<strong>Target</strong> 的含义是服务组，表示一组服务。</p><p><code>WantedBy=multi-user.target</code> 指的是，当前服务 所在的 <strong>Target</strong> 是<code>multi-user.target</code> .</p><p><code>Systemd</code> 有默认的启动 <strong>Target</strong>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ systemctl get-default
multi-user.target
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的结果表示，默认的启动 <strong>Target</strong> 是 <code>multi-user.target</code> 。在这个组里的所有服务，都将开机启动。这就是为什么 <code>systemctl enable</code> 命令能设置开机启动的原因。</p><p><strong>注：</strong></p><p>如果需要执行一些任务而非简单启动一个文件，也可以先编写bash脚本 <code>[name].sh</code> ，如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">nohup</span> /home/your_name/.config/clash/clash <span class="token parameter variable">-d</span> /home/your_name/.config/clash/ <span class="token operator">&gt;</span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后将 <code>ExecStart</code> 设为 <code>[name].sh</code> 所在的路径。</p><h4 id="执行bash命令" tabindex="-1"><a class="header-anchor" href="#执行bash命令" aria-hidden="true">#</a> 执行bash命令：</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 刷新配置文件</span>
<span class="token function">sudo</span> systemctl daemon-reload 

<span class="token comment"># 设置开机自启</span>
systemctl <span class="token builtin class-name">enable</span> <span class="token punctuation">[</span>name<span class="token punctuation">]</span>.service
<span class="token comment"># 启动服务</span>
systemctl start <span class="token punctuation">[</span>name<span class="token punctuation">]</span>.service

<span class="token comment"># 查看是否有效</span>
<span class="token function">sudo</span> systemctl status <span class="token punctuation">[</span>name<span class="token punctuation">]</span>.service
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="其他配置文件" tabindex="-1"><a class="header-anchor" href="#其他配置文件" aria-hidden="true">#</a> 其他配置文件</h2><p>系统安全文件 <code>/var/log/auth.log</code></p>`,14);function m(v,h){const a=i("ExternalLinkIcon");return c(),t("div",null,[r,e("p",null,[e("a",p,[d("[Install]解析："),o(a)])]),u])}const g=n(l,[["render",m],["__file","30.常用配置.html.vue"]]);export{g as default};
