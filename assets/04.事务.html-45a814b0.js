import{_ as a,p as s,q as n,a1 as e}from"./framework-c8e009f3.js";const o={},t=e(`<h2 id="什么是事务" tabindex="-1"><a class="header-anchor" href="#什么是事务" aria-hidden="true">#</a> 什么是事务</h2><p>多个语句顺序执行的任务被称为事务。<strong>某一条语句失败，整个事务应该被撤销</strong>。</p><h2 id="使用事务" tabindex="-1"><a class="header-anchor" href="#使用事务" aria-hidden="true">#</a> 使用事务</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h4><p>假如我有一个账户表，用户一想要向用户二转账200元，那么可以分离成两条mysql语句：</p><ul><li>用户一账户- 200元</li><li>用户二账户+ 200元</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> <span class="token number">200</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">+</span> <span class="token number">200</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> accounts<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="rollback" tabindex="-1"><a class="header-anchor" href="#rollback" aria-hidden="true">#</a> ROLLBACK</h4><p>ROLLBACK 用于主动回滚已执行的事务步骤：如</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> <span class="token number">100</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">+</span> <span class="token number">100</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="并行执行的事务" tabindex="-1"><a class="header-anchor" href="#并行执行的事务" aria-hidden="true">#</a> 并行执行的事务</h2><p>假如有两个客户端连接到了mysql服务端，并分别执行了事务A和事务B：</p><p>初始条件：<code>A = 2</code></p><p>| 时刻 | 事务A | 事务B | 1 | BEGIN; | BEGIN; | 2 | A = 1 | - | 3 | - | READ A | 4 | ROLLBACK | - | 5 | - | READ A</p><p>事务B两次读数据会读到什么样的结果呢？这里需要引入一个概念： <strong>隔离级别</strong>，根据隔离级别的不同，事务B将会读取到不一样的结果：</p><h4 id="read-uncommitted" tabindex="-1"><a class="header-anchor" href="#read-uncommitted" aria-hidden="true">#</a> Read Uncommitted</h4><p><code>Read Uncommitted</code> 是隔离级别最低的一种事务。以刚才的例子来说明，两次读结果分别为2 ， 1</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>当读取数据和最终数据不一致时，称该次读取为 <strong>脏读</strong></p></div><h4 id="read-committed" tabindex="-1"><a class="header-anchor" href="#read-committed" aria-hidden="true">#</a> Read committed</h4><p><code>Read commited</code> ， 读取提交或回滚后的数据，如果另一个事务正在执行，则无视它，读初始数据。 以刚才的例子来说明，两次读结果分别为 1 ， 1。</p><h4 id="repeatable-read" tabindex="-1"><a class="header-anchor" href="#repeatable-read" aria-hidden="true">#</a> Repeatable Read</h4><p>事务内的空间和其他事务<strong>完全隔离</strong>。即使另一个事务提交了也读不到对方修改的最新数据，<strong>但是可以更新数据</strong>，举例说明：</p><p>初始条件：空</p><p>| 时刻 | 事务A | 事务B | 1 | BEGIN; | BEGIN; | 2 | 插入 A = 1 | - | 3 | COMMIT | - | 4 | - | READ A = empty | 5 | - | UPDATE A = 2 | 6 | - | READ A = 2</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>正常来说读取不到一条记录直接去修改它会报错。但是在这种情况下修改成功了。</p><p>也就是说这种完全隔离<strong>仅针对读操作</strong>，并不应该写操作。</p><p>这种读不到最新数据的情况被称为 <em>幻读(Phantom Read)</em></p></div><h4 id="serializable" tabindex="-1"><a class="header-anchor" href="#serializable" aria-hidden="true">#</a> Serializable</h4><p><code>Serializable</code> 是最严格的隔离级别。 所有事务串行执行，<strong>不会出现脏读，幻读 ，但效率很低</strong></p><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是 <code>Repeatable Read</code>。</p>`,29),p=[t];function c(r,d){return s(),n("div",null,p)}const i=a(o,[["render",c],["__file","04.事务.html.vue"]]);export{i as default};
