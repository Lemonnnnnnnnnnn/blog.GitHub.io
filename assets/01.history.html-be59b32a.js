import{_ as e,M as t,p as o,q as r,R as n,t as i,N as c,a1 as s}from"./framework-c8e009f3.js";const p={},l=s(`<p><code>createWebHashHistory 与 createWebHistory</code>是创建路由历史记录对象<code>history</code>的两种方法</p><p>示例：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createRouter<span class="token punctuation">,</span> createWebHashHistory <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue-router&#39;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/&#39;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;首页&#39;</span><span class="token punctuation">,</span>
        <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;./App.vue&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>

<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">createRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">history</span><span class="token operator">:</span> <span class="token function">createWebHashHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    routes
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> router
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="createwebhashhistory" tabindex="-1"><a class="header-anchor" href="#createwebhashhistory" aria-hidden="true">#</a> createWebHashHistory</h3><p>假设我们的域名是<code>http://domain/</code> ，在url地址栏你将看到<code>http://domain/#/home</code>这样的url形式。</p><ol><li><code>#</code> 有什么用？</li></ol><p><code>#</code>后面的值并不会被发送到服务端。也就是说后端接收到的地址为<code>http://domain/</code> 。</p><ol start="2"><li>为什么要进行这种设计？</li></ol><p>首先，浏览一个网页的过程是：用户输入url地址 ---- &gt; url地址发送给后端 ---- &gt; <strong>后端根据url地址的异同返回页面给客户端</strong></p><p>作为一个单页应用，虽然url地址总在改变，但发送给后端的地址应该<strong>总是相同的</strong>，这样可以最大程度利用<strong>缓存数据</strong>, 而不用花巨大的开销在<strong>发送接收请求和下载文档</strong>上。</p>`,10),d={start:"3"},u={href:"https://zhuanlan.zhihu.com/p/337073166",target:"_blank",rel:"noopener noreferrer"},v=s(`<p>对于前端：</p><p><strong>路由的哈希模式其实是利用了window.onhashchange事件，也就是说你的url中的哈希值（#后面的值）如果有变化，就会自动调用hashchange的监听事件，在hashchange的监听事件内可以得到改变后的url，这样能够找到对应页面进行加载</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>window.addEventListener(&#39;hashchange&#39;, () =&gt; {
   // 把改变后的url地址栏的url赋值给data的响应式数据current，调用router-view去加载对应的页面
   this.data.current = window.location.hash.substr(1)
})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于后端： <strong>#是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括#。</strong></p><ol start="4"><li>有什么弊端？</li></ol><p><code>SEO</code>上表现很差</p><h4 id="createwebhistory" tabindex="-1"><a class="header-anchor" href="#createwebhistory" aria-hidden="true">#</a> createWebHistory</h4><p><code>createWebHistory</code>没有使用<code>#</code>来实现单页应用的路由，那么他是如何实现一样的效果呢？</p><p>其原理是调用了<code>HTML5</code>中的<code>pushState() 和 replaceState() 方法</code>，功能是替换url但不刷新页面，换言之，<strong>更新url并不会发送请求给后端</strong>。</p><ol><li>有什么弊端？</li></ol><p>当我们<strong>重新刷新了页面</strong>或者 <strong>直接访问某个路由</strong>，这时是<strong>一定会发送请求</strong>，而单页应用中，后端只有一个首页资源，于是客户端会得到一个<strong>404状态码</strong>。</p><ol start="2"><li>如何解决问题？</li></ol><p>后端在服务端配置（一般是nginx中）加上一条规则：<strong>如果网址与任何静态资源都不匹配，则返回首页</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>location / {
  try_files $uri $uri/ /index.html; # 
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p><code>try_files</code> : 按顺序查找文件，并返回第一个找到的文件，若找不到，返回最后一个参数（回退地址） <code>$uri</code> : Nginx基础内置变量，请求的资源名</p></div>`,15);function h(k,m){const a=t("ExternalLinkIcon");return o(),r("div",null,[l,n("ol",d,[n("li",null,[n("a",u,[i("如何把前后端获得的url地址区分开来？"),c(a)])])]),v])}const b=e(p,[["render",h],["__file","01.history.html.vue"]]);export{b as default};
