import{_ as s,p as n,q as a,a1 as c}from"./framework-c8e009f3.js";const e={},t=c(`<h1 id="css的解析过程" tabindex="-1"><a class="header-anchor" href="#css的解析过程" aria-hidden="true">#</a> css的解析过程</h1><p><strong>浏览器是如何通过html,css将网页显示出来的？</strong></p><ol><li>通过html文件构建DOM树</li><li>根据css文件构建CSSOM树（CSS规则树）</li><li>通过元素的选择器等，将两者进行<strong>匹配</strong>，合成渲染树（将样式附到DOM树上）</li></ol><p><strong>匹配过程是怎样的？</strong></p><p>假设有一个css文件，以及一个DOM树</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">.mod-nav h3 span</span> <span class="token punctuation">{</span> <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://linyc.oss-cn-beijing.aliyuncs.com/css&amp;dom_tree.png" alt=""></p><p>如果从上往下进行匹配（从左向右解析CSS代码）<code>.mod-nav → h3 → span</code>，则要遍历整棵树。但如果从下往上进行匹配（从右向左解析CSS代码）<code>span → h3 → .mode-nav</code>，则只要寻找目标结点的父节点即可，大大减少遍历的结点数。</p><p>因此CSS解析的原则是<strong>从右向左</strong>。</p><p><strong>怎样算匹配成功？</strong></p><p>其内部编写了一套匹配规则：</p><p><img src="https://linyc.oss-cn-beijing.aliyuncs.com/css_priority.png" alt=""></p>`,12),o=[t];function p(i,l){return n(),a("div",null,o)}const d=s(e,[["render",p],["__file","25.css的解析过程.html.vue"]]);export{d as default};
