import{_ as e,p as d,q as o,a1 as c}from"./framework-c8e009f3.js";const a={},t=c(`<h2 id="store" tabindex="-1"><a class="header-anchor" href="#store" aria-hidden="true">#</a> store</h2><p><code>configureStore</code> 的可选项：</p><div class="language-javaScript line-numbers-mode" data-ext="javaScript"><pre class="language-javaScript"><code>export interface ConfigureStoreOptions {
    reducer: Reducer&lt;S, A&gt; | ReducersMapObject&lt;S, A&gt;;
    middleware?: ((getDefaultMiddleware: CurriedGetDefaultMiddleware&lt;S&gt;) =&gt; M) | M;
    devTools?: boolean | DevToolsOptions;
    preloadedState?: PreloadedState&lt;CombinedState&lt;NoInfer&lt;S&gt;&gt;&gt;;
    enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>enhancers</code>允许我们为原有的<code>dispatch, getState, and subscribe</code>添加一些新特性.但多数情况下，我们只需修改<code>dispatch</code>即可，而在这方面上，使用<code>middleware</code>是个更好的选择。</p><h2 id="middleware" tabindex="-1"><a class="header-anchor" href="#middleware" aria-hidden="true">#</a> middleware</h2><p>es6的<code>generate</code> 特性让中间件在<code>nodejs</code>中变得十分流行，在完成了中间件功能后，可以直接调用<code>next()</code>来进入下一个流程。它让所有任务能够<strong>链式调用</strong>。在redux中我们主要使用中间件来处理<code>dispatch action</code>到 <code>reducer</code>之间的流程。</p><h2 id="flux-standard-actions" tabindex="-1"><a class="header-anchor" href="#flux-standard-actions" aria-hidden="true">#</a> Flux Standard Actions</h2><p><code>Flux</code> 来自于拉丁语的 <code>Flow</code>，意思是 <strong>数据和逻辑永远单向流动</strong> ， <code>Flux standart actions</code> 即按照 <code>Flux</code>标准的 <code>redux-actions</code></p><p><code>Redux store</code>其实不在意你在 <code>action</code> 中放置了哪些属性，它只关心 <code>action.type</code>。但如果对 <code>action</code> 的属性值没有任何规范的话，我们就很难提前知道自己要如何处理每一个 <code>reducer</code> 中的数据。因此我们需要一个<code>Flux</code>标准，标准如下：</p><p><strong>数据存放</strong>：</p><ul><li>如果有 <code>data</code>，请放在 <code>action.payload</code> 中</li><li><code>action.meta</code>存放额外的描述信息，可选</li><li><code>action.error</code>：布尔值，是否发生错误，若发生错误，<code>payload</code>存放error信息 ，可选</li></ul><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>在redux社区中， <code>action.error</code>的应用并不广泛，设计者更倾向于用分离 <code>action</code>来解决问题。例如：</p><p>定义成功请求的 <code>action</code> 为 <code>&#39;todos/todosLoadingSucceeded&#39;</code>，并在相应 <code>reducer</code>中处理</p><p>定义失败请求的 <code>action</code> 为 <code>&#39;todos/todosLoadingFailed&#39;</code>，并在相应 <code>reducer</code>中处理</p></div><p><strong>必填项</strong></p><ul><li><code>action</code>必须是一个扁平的 <code>javaScript object</code> ,</li><li><code>action</code>必须有<code>type</code>属性</li></ul>`,14),r=[t];function i(n,s){return d(),o("div",null,r)}const u=e(a,[["render",i],["__file","15.标准redux模式.html.vue"]]);export{u as default};
