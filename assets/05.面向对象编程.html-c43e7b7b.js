import{_ as p,M as o,p as c,q as l,R as s,t as n,N as t,a1 as a}from"./framework-c8e009f3.js";const i={},u=a(`<h2 id="基础使用" tabindex="-1"><a class="header-anchor" href="#基础使用" aria-hidden="true">#</a> 基础使用</h2><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>

bart <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token punctuation">)</span>
bart<span class="token punctuation">.</span>hello<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义类的方法时，第一个参数一定是 <code>self</code>，即类的实例，在调用方法，如 <code>bart.hello()</code> 会默认将调用者作为 <code>self</code> 实例传入函数的第一个参数位置，python中函数参数的数量是严格定义的，如果没有定义<code>self</code> 参数，但是却传了一个参数，会得到报错：<code>hello() takes 0 positional arguments but 1 was given</code></p><h2 id="私有属性" tabindex="-1"><a class="header-anchor" href="#私有属性" aria-hidden="true">#</a> 私有属性</h2>`,4),d={href:"/python/04.%E6%A8%A1%E5%9D%97.html",target:"_blank",rel:"noopener noreferrer"},r=s("em",null,[n("类中的属性如果被命名为 "),s("code",null,"__xxx"),n(" 则会被真正转换为私有属性")],-1),k=a(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self <span class="token punctuation">,</span> name <span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>__age <span class="token operator">=</span> age

bart <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">&#39;bart&#39;</span> <span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>bart<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>bart<span class="token punctuation">.</span>__age<span class="token punctuation">)</span>  <span class="token comment"># AttributeError: &#39;Student&#39; object has no attribute &#39;__age&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事实上，<code>__xxx</code>会被python解释器转换为<code>_类名__xxx</code> 的形式。</p><h2 id="私有属性的继承" tabindex="-1"><a class="header-anchor" href="#私有属性的继承" aria-hidden="true">#</a> 私有属性的继承</h2><p>我们实现一个 <strong>Monitor类</strong> 继承于Student类，我们为两个类都实现了 <code>__init__</code>的初始化方法，想看看实际上会调用哪一个：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self <span class="token punctuation">,</span> name <span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;init student&#39;</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>__name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>__age <span class="token operator">=</span> age

    <span class="token keyword">def</span> <span class="token function">get_name</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>__name<span class="token punctuation">)</span> 

<span class="token keyword">class</span> <span class="token class-name">Monitor</span><span class="token punctuation">(</span>Student<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self <span class="token punctuation">,</span> name <span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;init monitor&#39;</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>__name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>__age <span class="token operator">=</span> age


bart <span class="token operator">=</span> Monitor<span class="token punctuation">(</span><span class="token string">&#39;bart&#39;</span> <span class="token punctuation">,</span> <span class="token number">18</span> <span class="token punctuation">)</span>

bart<span class="token punctuation">.</span>get_name<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果打印出了 <code>init monitor</code> 和 <code>报错&#39;Monitor&#39; object has no attribute &#39;_Student__name&#39;</code>，好了，现在我们知道会优先调用子类的构造方法。</p><p>嗯？为什么我调用继承来的方法报错了？看来python解释器在编译私有属性的时候并不是通过调用者来编译的，我们想象的情况是：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>bart <span class="token operator">=</span> Monitor<span class="token punctuation">(</span><span class="token string">&#39;bart&#39;</span> <span class="token punctuation">,</span> <span class="token number">18</span> <span class="token punctuation">)</span> <span class="token comment"># 通过 Monitor类构造一个实例</span>
bart<span class="token punctuation">.</span>get_name<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 调用实例的get_name()方法，方法打印\`self.__name\`，self.__name应该是构造类的名字，应该被编译成_Monitor__name</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>实际的状况是：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>bart<span class="token punctuation">.</span>get_name<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 调用实例的get_name()方法,方法来自于 class Student ，self.__name被编译成 _Student__name</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>好吧，那我们有三种办法解决这种情况：</p><ol><li>实现子类的 <code>get_name</code> 方法：</li></ol><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Monitor</span><span class="token punctuation">(</span>Student<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self <span class="token punctuation">,</span> name <span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;init monitor&#39;</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>__name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>__age <span class="token operator">=</span> age

    <span class="token keyword">def</span> <span class="token function">get_name</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>__name<span class="token punctuation">)</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>主动调用父类的构造方法：</li></ol><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Monitor</span><span class="token punctuation">(</span>Student<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self <span class="token punctuation">,</span> name <span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>name <span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token comment"># 调用父类的构造器</span>
       
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>在子类中获取父类实例有两种方法：</p><p>python3 : super()</p><p>python2 : super(子类名, self) 【(继承类，继承实例)】</p></div><ol start="3"><li>不定义子类的构造方法，默认使用父类的构造方法</li></ol><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Monitor</span><span class="token punctuation">(</span>Student<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,18),v={href:"http://zhangming0509.github.io/2016/01/29/python-private-attribute-inherient/#:~:text=%E5%9C%A8python%E4%B8%AD%E4%BB%A5%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E5%BC%80%E5%A4%B4%E7%9A%84%E5%B1%9E%E6%80%A7%E6%98%AF%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%EF%BC%8C%E7%84%B6%E8%80%8Cpython%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E4%B8%8D%E6%98%AF%E7%BB%9D%E5%AF%B9%E7%9A%84%E7%A7%81%E6%9C%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%20_%E7%B1%BB%E5%90%8D__%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%20%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%8C%E7%8E%B0%E6%9C%89%E5%A6%82%E4%B8%8B%E4%B8%A4%E4%B8%AA%E7%B1%BB%2C,child%20%E5%92%8C%20Father%20%EF%BC%9A",target:"_blank",rel:"noopener noreferrer"},m=a(`<h2 id="静态属性" tabindex="-1"><a class="header-anchor" href="#静态属性" aria-hidden="true">#</a> 静态属性</h2><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    name <span class="token operator">=</span> <span class="token string">&#39;Student&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="动态添加属性和-slots" tabindex="-1"><a class="header-anchor" href="#动态添加属性和-slots" aria-hidden="true">#</a> 动态添加属性和__slots__</h2><p>python允许我们直接操作类的实例，为其动态添加一些属性：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>

liming <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token punctuation">)</span>

liming<span class="token punctuation">.</span>hello <span class="token operator">=</span> <span class="token keyword">lambda</span> <span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>
liming<span class="token punctuation">.</span>hello<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># hello</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>__slots__</code>的能够为这些需要动态添加的属性或方法预先提供一个“插槽”，插槽中未定义的属性将不能被添加进类实例中：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    __slots__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>
    

liming <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token punctuation">)</span>

liming<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;liming&#39;</span>  <span class="token comment"># &#39;Student&#39; object has no attribute &#39;name&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但实际上，<code>slots</code> 的核心功能是内存优化：当我们初始化一个类时，实际上会为其定义一个字典表 <code>__dict__</code> ，用于动态扩展属性。而当我们使用了插槽后，实例的属性被确定下来，类不再需要 <code>__dict__</code> 而是用一个静态数据结构存储类实例属性，不但极大减少内存空间的占用而且拥有比字典更快的执行速度（静态结构的性能总是更优）。</p><h3 id="关于-slots-继承问题" tabindex="-1"><a class="header-anchor" href="#关于-slots-继承问题" aria-hidden="true">#</a> 关于 slots 继承问题</h3>`,9),_={href:"https://www.cnblogs.com/rainfd/p/slots.html",target:"_blank",rel:"noopener noreferrer"},b=a(`<ul><li>父类有<code>__slots__</code> ， 子类没有：子类会自动创建 <code>__dict__</code> 字典表</li><li>父类没有，子类有，子类会继承父类字典表</li><li>子类有，父类有，只看子类slots</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span> __slots__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;b&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">:</span> __slots__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;c&#39;</span><span class="token punctuation">)</span>

a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> B<span class="token punctuation">(</span><span class="token punctuation">)</span>

b<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token string">&#39;b&#39;</span>  <span class="token comment"># &#39;B&#39; object has no attribute &#39;b&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>廖雪峰老师的表述是子类父类都有slots，则会合并。与笔者尝试不符，猜测是python版本问题，笔者是 python3.10.4</p></div><h2 id="常用方法" tabindex="-1"><a class="header-anchor" href="#常用方法" aria-hidden="true">#</a> 常用方法</h2><p>对象是否拥有某个属性 <code>hasattr</code> ：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">readImage</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">hasattr</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">&#39;read&#39;</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> readData<span class="token punctuation">(</span>fp<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">None</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6);function h(g,y){const e=o("ExternalLinkIcon");return c(),l("div",null,[u,s("p",null,[n("我们"),s("a",d,[n("上一节"),t(e)]),n("提到过："),r,n(" ， 现在我们来尝试一下：")]),k,s("p",null,[n("关于详细私有属性的继承情况，这里有总结"),s("a",v,[n("python私有同名属性的继承"),t(e)])]),m,s("p",null,[n("参考"),s("a",_,[n("Python__slots__详解"),t(e)])]),b])}const f=p(i,[["render",h],["__file","05.面向对象编程.html.vue"]]);export{f as default};
